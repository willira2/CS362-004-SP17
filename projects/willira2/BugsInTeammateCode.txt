Bug Report #1Title:  Smithy card displays incorrect game behavior
Class: card implementation bug
Date:  5/28/17  
       Reported By:Rachel WilliamsIs it reproducible? YesDescriptionSteps to Produce/Reproduce:•	Initialize a valid gameState game •	Place Smithy card into current player’s hand at any handPos•	Call Smithy card implementation by calling cardEffect and passing the Smithy card, gameState, and Smithy’s handPos in the appropriate order. Set all other arguments to 0.Method Found:This bug was discovered in both the cardtest and the randomtest. Expected Results:After the function call, the handCount of the current player should be equal to the previous handCount + 2, and there should be one fewer Smithy cards in the hand.Actual Results:After the function call, the handCount of the current player is equal to the previous handCount + 1. Workarounds:NoneCause of bug:In the smithyCard function of dominion.c, the loop to draw cards starts at i=1 and runs to i < 3, ie, the loop only runs twice, and two cards are drawn instead of three. Then, the smithy card is discarded, and so the net change to the player’s hand is +1 instead of +2.I found this bug by inspecting the smithyCard function’s method of drawing cards and hand tracing the loop.Estimated Severity:Low severity. This bug does not create catastrophic failure or pose a security concern.Estimated Priority:Medium-high priority. This bug prevents proper gameplay, and there are no workarounds.


Bug Report #2Title:  Adventurer card displays incorrect game behaviorClass: card implementation bugDate:  5/28/17         Reported By:Rachel WilliamsIs it reproducible? YesDescriptionSteps to Produce/Reproduce:•	Initialize a valid gameState game •	Place Adventurer card into current player’s hand at any handPos•	Call Adventurer card implementation by calling cardEffect and passing the Adventurer card and gameState in the appropriate order. Set all other arguments to 0.Method Found:This bug was discovered in both the cardtest and the randomtest. Expected Results:After the function call, the handCount of the current player should be equal to the previous handCount + 1 if two treasure cards were found in the deck, previous handCount if one treasure card was found in the deck, or previous handCount-1 if no treasure cards were found in the deck, and there should be one fewer Adventurer cards in the hand in any case.Actual Results:if there are >=2 treasure cards in the deck, the handCount ends up with 2 extra cards, and the Adventurer card is not discarded. If there are <2 treasure cards in the deck, the handCount has one extra card, and the Adventurer card is not discarded. Workarounds:NoneCause of bug:In the adventurerCard function of dominion.c, the while loop that runs until a set number of treasure cards is found stops when drawnTreasure == 2. This is incorrect. drawnTreasure is initially set to 0, and in order to only draw two cards, it should stop when drawnTreasure < 2. This explains why the expected number of cards in the hand and the actual number of cards is not consistent for every situation. When there are fewer than 2 treasure cards in the discard pile, the while loop ends once it has looped through the entire discard pile, and so the hand ends up with only one extra card, the Adventurer card, instead of more.The adventurer card is not discarded at the end of the function, which is why it remains in the player’s hand.I found this bug by inspecting the adventurerCard function and tracing its initial argument values back to cardEffect(), and then handtracing the while loop.Estimated Severity:Low severity. This bug does not create catastrophic failure or pose a security concern.Estimated Priority:Medium-high priority. This bug prevents proper gameplay, and there are no workarounds.Notes:This is an interesting bug because it highlights how important it is to test multiple gameState variations. The random test did not catch the difference in the pattern when the discard pile had fewer than 2 treasure cards, but the unit test, which tested more situations, did. Both tests caught the bug, but the unit test gave more information about it.